## هوش مصنوعی
هوش مصنوعی شامل تکنیکهای مختلفی است که در ظاهر به رفتارهای همراه با ادراک توسط کامپیوتر شبیه هستند.
برای مثال، از AI برای تشخیص چهره در عکسهای موجود در رسانه های اجتماعیتان، شکست دادن قهرمان جهانی شطرنج
و پردازش گفتارتان هنگام استفاده از نرم افزارهای سیری یا الکسا استفاده میشود.
در این دوره، بعضی از مفاهیمی که امکان استفاده از AI را فراهم می آورند بررسی میکنیم:

### 1.جست و جو
یافتن راه حل برای مسائل؛ مانند برنامه های مسیر یابی که بهترین مسیر از مبدأ تا مقصد را برایتان پیدا میکنند، یا مانند
سنجیدن حرکت بعدی در هنگام بازی کردن.

### 2.دانش
بازنمایی اطلاعات و استنباط کردن از آ نها.

### 3.عدم قطعیت
مواجهه با رویدادهای غیرقطعی بر اساس احتمالات.

### 4.بهینه سازی
تنها به دنبال پیدا کردن روش صحیحِ حل مسائل نیست، بلکه هدف آن پیدا کردن روش بهتر یا بهترین روش برای حل
مسائل است.

### 5.یادگیری
بهبود عملکرد بر اساس دسترسی به داده ها و تجربیات؛ برای مثال، ایمیل شما قادر است بر اساس تجارب گذشته ایمیل های
اسپم را از غیراسپم تشخیص دهد.

### 6.شبکه های عصبی
ساختار برنامه ای با الهام از مغز انسان که قادر است وظایف را به نحو مؤثری انجام دهد.

### 7.زبان
پردازش زبان های طبیعی که توسط انسان ها تولید و درک میشود.



## جستوجو
مسئله جستجو شامل یک عامل با یک حالت اولیه و یک حالت نهایی است. جستجو در واقع راه حلِ رفتن از حالت اول به
حالت دوم را نشان می دهد. برنامه های مسیریابی از فرایند جستجوی معمولی استفاده می کنند که در آن، عامل (قسمت متفکر
برنامه) مکان فعلی و مقصد مدنظر شما را به عنوان ورودی خود دریافت میکند و بر مبنای یک الگوریتم جستجو، مسیری را
پیشنهاد می دهد. البته شکل های بسیار متنوعی برای مسائل جستجو وجود دارد، از جمله پاز ل ها یا هزارتو ها یافتن راه حل برای پازل پانزده خانه ای اعداد مستلزم استفاده از الگوریتم جستجو است.

### عامل
موجودیتی که محیطش را درک و بر اساس آن عمل میکند. برای مثال، در برنامۀ مسیریابی، عامل نوعی بازنمایی از یک
خودروست که باید تصمیم بگیرد چه اقداماتی را برای رسیدن به مقصد انجام دهد.

### حالت
پیکربندی (configuration) عامل در محیطش؛ برای مثال، در پازل پانزده خانه ای اعداد، حالت یعنی هر یک از شکل هایی که
اعداد روی تخته چیده می شوند.

#### حالت اولیه
حالتی که از آ نجا، الگوریتم جستجو آغاز می شود. در برنامۀ مسیریابی، حالت اولیه همان مکان فعلی است.


### اعمال
انتخاب هایی که می توان در یک حالت انجام داد. به بیان دقیق تر می توان اعمال را به صورت یک تابع تعریف کرد. با دریافت
حالت s به عنوان ورودی، Actions(s) مجموع های از اعمالی را که می توان در حالت s انجام داد، به عنوان خروجی به ما
می دهد. برای مثال، در پازل پانزده خانه ای اعداد، اعمال یک حالت معین عبارتند از راههایی که می توانید مربعها را در چیدمان
فعلی حرکت دهید (عدد 4 اگر مربع خالی در وسط باشد، عدد 3 اگر کنار ضلع باشد، عدد 2 اگر در گوشه قرار گرفته باشد).

### مدل انتقال (Transition model)
مدلی که توصیف می کند که پس از اجرای هر عملِ قابل انجام در هر حالت، چه حالتی به دست می آید. به بیان دقیق تر، مدل
انتقال را می توان به صورت یک تابع تعریف کرد. با دریافت حالت s و عمل a به عنوان ورودی، Results(s, a) حالتی را که
از اجرای عمل a در حالت s به دست می آید، به ما می دهد. برای مثال، با توجه به چیدمان خاصی برای پازل پانزده خانه ای
اعداد (حالت s)، حرکت دادن یکی از مربع ها در یک جهت (عمل a)، چیدمان جدیدی برای پازل ایجاد می کند (حالت جدید).

### فضای حالت
مجموع های از تمامی حالت هایی که از طریق هر نوع توالی اعمال در حالت اولیه، به دست خواهند آمد. برای مثال، در پازل
پانزده خانه ای اعداد، فضای حالت ها شامل 16!/2 پیکربندی تخته میشود که می توان آ نها را از هر نوع حالت اولیه ای
به دست آورد . فضای حالت را می توان به صورت گراف جهت داری مجسم کرد که در آن گره ها نشان دهندۀ حالت ها و پیکان های
بین گره ها نشان دهندۀ اعمال هستند.

### آزمون هدف
شرایطی که تعیین می کند آیا یک حالت معین، حالت نهایی است یا خیر. برای مثال، در برنامۀ مسیریابی، آزمون هدف بررسی
می کند که آیا مکان فعلیِ عامل (بازنمایی خودرو) در مقصد است یا خیر. اگر باشد، پس مسئله حل شده است. اگر نباشد، به
جستجو ادامه می دهیم.

### هزینۀ مسیر
هزینۀ عددیِ متناظر با مسیری معین. برای مثال، برنامۀ مسیریابی صرفاً شما را به هدف نمی رساند؛ بلکه به طور همزمان،
هزینۀ مسیر را به حداقل می رساند و سریع ترین راه ممکن برای رسیدن شما به حالت نهایی تان را پیدا می کند.


## حل مسائل جستجو
راه حل: 
توالی اعمالی که ما را از حالت اولیه به حالت نهایی هدایت می کنند.

راه حل بهینه:
راه حلی که کمترین هزینۀ مسیر را نسبت به تمامی راه حل ها دارد.


در فرایند جستجو، داده ها اغلب در یک گره ذخیره می شوند، گره ساختمان دادهای شامل اطلاعات زیر است:
  - حالت
  - گره وا لد ، که گره فعلی از طریق آن ایجاد شده است
  - عملی که روی حالت والد انجام شد تا به گره فعلی برسد
  - هزینۀ مسیر از حالت اولیه تا این گره


گره ها حاوی اطلاعاتی هستند که باعث می شود به ساختمان داده ای بسیار مفید برای استفاده در الگوریتم های جستجو تبدیل
شوند. آ نها دارای حالتی هستند که می توان آن را با استفاده از آزمون هدف بررسی کرد تا مشخص شود آیا این همان حالت
نهایی است یا خیر. اگر حالت نهایی باشد، آنگاه می توان هزینۀ مسیر گره را با هزینه های مسیر سایر گره ها مقایسه کرد؛ این
کار امکان انتخاب راه حل بهینه را میسر  می سازد. زمانی که گره انتخاب می شود می توان با ذخیره سازی گره والد و عملی که
از والد به گره فعلی هدایت کرده است، تمامی مراحل — از حالت اولیه تا این گره — را ردیابی کرد؛ این توالی اَعمال، راه حل
نام دارد.

اما گره ها صرفاً یک ساختمان داده هستند — آ نها جستجو نمی کنند، فقط حاوی اطلاعات هستند. برای انجام جستجوی
واقعی، از frontier استفاده می کنیم. یعنی مکانیسمی که گره ها را (مدیریت می کند). frontier کار خود را با حالت اولیه
و مجموعه ای خالی از گزینه های بررسی شده آغاز می کند. سپس، اَعمال زیر را تکرار می کند تا زمانی که راه حلی به دست آید:

حلقه ی تکرار:

#### 1.اگر frontier خالی بود
  - متوقف شوید. هیچ راه حلی برای مسئله وجود ندارد.
 
#### 2.گره ی را از frontier بردارید. این همان گرهی است که بررسی خواهد شد.
 
#### 3.اگر گره حاوی حالت نهایی بود،
  - راه حل به دست آمده است. متوقف شوید.
در غیر این صورت،
  - گره را بسط دهید (تمامی گره های جدیدی را که می توان از این گره به دست آورد پیدا کنید) و گره های
به دست آمده را به frontier اضافه کنید.
  - گره فعلی را به مجموعۀ بررسی شده ها اضافه کنید.


## جستجوی اول عمق (DFS)
در تشریح قبلی frontier ، یک مسئله ناگفته ماند. در مرحلۀ 1 شبه کد بالا، کدام گره باید برداشته شود؟ این انتخاب، روی
کیفیت راه حل و سرعت دستیابی به آن تأثیر می گذارد. به رو شهای مختلفی میتوان دریافت که کدام گره ها باید اول بررسی
شوند، که دو مورد از این روش ها را می توان با استفاده از ساختمان داده ی پشته (در جستجوی اول عمق) و صف (در جستجوی
اول سطح (BFS) نشان داد).
با رویکرد جستجوی اول عمق (DFS) شروع می کنیم.

الگوریتم جستجوی اول عمق، ابتدا یک مسیر را کامل طی می کند و سپس مسیر دیگری را امتحان می کند. در این الگوریتم،frontier
با استفاده از ساختمان داده پشته مدیریت می شود. تکیه کلامی که باید در اینجا به یاد داشته باشید(آخرین ورودی, اولین خروجی)
است. پس از اینکه گرهها به » اولین خروجی frontier اضافه شدند، اولین گرهی که باید حذف و بررسی شود، آخرین گره
اضافه شده است. این امر باعث میشود الگوریتم جستجویی داشته باشیم که در اولین جهتی که در مسیرش قرار میگیرد، تا
بیشترین عمق ممکن پیش می رود و همۀ جهت های دیگر را به بعد موکول میکند.
(مثال غیردرسی: مثلاً در نظر بگیرید که به دنبال کلیدهایتان می گردید. در رویکرد جستجوی اول عمق، اگر بخواهید کار را
با جستجوی شلوارتان شروع کنید باید همۀ جیب ها را بگردید، آ نها را خالی کنید و وسایل آن را به دقت بگردید. تنها پس از
اینکه جستجو در همۀ جیب های شلوارتان را تمام کرده باشید، از جستجوی شلوارتان دست می کشید و جای دیگری را
میگردید.)

#### مزایا :
  -در بهترین شرایط، این الگوریتم سریع ترین الگوریتم است. اگر (خوش شانسی بیاورد) و همیشه مسیر
صحیح راه حل را (به طور اتفاقی) انتخاب کند، آنگاه جستجوی اول عمق کمترین زمان ممکن را برای رسیدن
به راه حل خواهد برد.

#### معایب :
  - ممکن است راه حلِ پیدا شده، بهینه نباشد.
  - در بدترین شرایط، این الگوریتم تمامی مسیرهای ممکن را برای پیدا کردن راه حل بررسی می کند و بدین
ترتیب، بیشترین زمان ممکن را برای رسیدن به راه حل خواهد برد.

### شبه کد:
```python
# Define the function that removes a node from the frontier and returns it. 
def remove(self): 
  # Terminate the search if the frontier is empty, because this means that there is no solution. 
  if self.empty(): 
    raise Exception("empty frontier") 
  else: 
    # Save the last item in the list (which is the newest node added) 
    node = self.frontier[-1] 
    # Save all the items on the list besides the last node (i.e. removing the last node) 
    self.frontier = self.frontier[:-1] 
    return node
```

## جستجوی اول سطح
برعکس جستجوی اول عمق، جستجوی اول سطح (BFS) است.
الگوریتم جستجوی اول سطح، چند مسیر را به طور همزمان پیگیری می کند. این الگوریتم ابتدا گام اول را در هر یک از
مسیرهای ممکن بر میدارد، سپس به سراغ برداشتن گام دوم میرود. در این روش، frontier با استفاده از ساختمان داده ی
صف مدیریت می شود. تکیه کلامی که باید در اینجا به خاطر بسپارید. (اولین ورودی، اولین خروجی) است. در این الگوریتم،
تمامی گره های جدید به ترتیب به یک صف اضافه می شوند و گره ها بر اساس اینکه کدام یک پیش از بقیه اضافه شده است،
بررسی می شوند (آنکه اول آمده باشد اول پذیرایی میشود!). این باعث می شود الگوریتم جستجویی داشته باشیم که ابتدا در
هر مسیر ممکن یک گام بر میدارد، آ نگاه به سراغ برداشتن گام دوم در یکی از مسیرها می رود.
(مثال غیردرسی: فرض کنید به دنبال کلیدهای خود هستید. در این مورد، اگر جستجو را با شلوارتان شروع کنید، جیب راست
خود را خواهید گشت. سپس، به جای اینکه جیب چپ خود را بگردید، کشوی کمد را می گردید. سپس روی میز را نگاه می کنید.
و به همین ترتیب، هر مکانی که فکرش را می کنید می گردید. فقط زمانی که همۀ مکان های دیگر را تمام کرده باشید، دوباره
سراغ شلوارتان می آیید و جیب دوم را می گردید.)

#### مزایا :
  - این الگوریتم حتما راه حل بهینه را پیدا کند (اگر وجود داشته باشد).

#### معایب :
  - تقریباً می توان یقین داشت که مدت زمان اجرای این الگوریتم بیشتر از حداقل زمان اجراست.
  - در بدترین شرایط، اجرای این الگوریتم بیشترین زمان ممکن را خواهد برد.

### شبه کد:
```python
# Define the function that removes a node from the frontier and returns it. 
def remove(self): 
  # Terminate the search if the frontier is empty, because this means that there is no solution. 
  if self.empty(): 
    raise Exception("empty frontier") 
  else: 
    # Save the oldest item on the list (which was the first one to be added) 
    node = self.frontier[0] 
    # Save all the items on the list besides the first one (i.e. removing the first node) 
    self.frontier = self.frontier[1:] 
    return node
```

## جستجوی اول بهترین حریصانه
اول سطح و اول عمق، در دسته ی الگوریتم های جستجوی ناآگاهانه هستند. یعنی این الگوریتم ها، خارج از اکتشافات خودشان،
از هیچ دانشی دربارۀ مسئله استفاده نمی کنند. این درحالی است که اغلب اوقات، دانش دربارۀ آن مسئله تا حدودی در دسترس
است. برای مثال، زمانی که یک حل کنندۀ انسانیِ هزارتو وارد تقاطع میشود می تواند بفهمد کدام راه در مسیر کلیِ راه حل
قرار داد و کدام قرار ندارد. هوش مصنوعی نیز می تواند چنین کند. الگوریتمی که از دانش اضافی برای بهبود عملکردش
استفاده می کند، الگوریتم جستجوی آگاهانه نام دارد.
جستجوی اول بهترین حریصانه، گرهی را که بر اساس تابعی هیوریستیک مانند h(n)، از همه به هدف نزدیکتر است گسترش
میدهد. هما نطور که از نام آن پیداست، این تابع میزان نزدیکی گره بعدی به هدف را تخمین می زند اما ممکن است این
تخمین اشتباه باشد. کارایی الگوریتم اول بهترین حریصانه به میزان مطلوبیت تابع هیوریستیک بستگی دارد. برای مثال، در
یک هزارتو، الگوریتم می تواند از تابع هیوریستیکی استفاده کند که به فاصلۀ منهتن بین گره های محتمل و نقطه هدف در
هزارتو متکی است. فاصلۀ منهتن دیوارها را نادیده می گیرد و تعداد گام هایی را که برای رسیدن از یک موقعیت به موقعیت
هدف باید به سمت بالا، پایین یا چپ و راست برداشته شوند، می شمارد. این تخمین ساده ای است که میتوان آن را بر مبنای
مختصات (x, y) موقعیت فعلی و موقعیت هدف به دست آورد.


### فاصلۀ منهتن
البته باید تأکید کنیم که این فاصله نیز، همانند هر هیوریستیک دیگر، ممکن است اشتباه باشد و باعث شود الگوریتم از مسیر
کُندتری برود. در حالی که اگر از مسیر دیگری می رفت، سریع تر به جواب می رسید. ممکن است یک الگوریتم جستجوی
ناآگاهانه، راه حل بهتری را سریع تر پیدا کند اما احتمال این کار، در مقایسه با الگوریتم های آگاهانه، کمتر است.


### جستجوی A*
جستجوی A* ، که حالت توسعه یافتۀ الگوریتم اول بهترین حریصانه است، علاوه بر درنظرگرفتن h(n) — یعنی هزینۀ تخمینی
از موقعیت فعلی تا هدف.، g(n) — یعنی هزینه ای که برای رسیدن به موقعیت فعلی صرف شده است را نیز در نظر می گیرد.
این الگوریتم، با ترکیب کردن این دو مقدار، روش دقیق تری برای تعیین هزینۀ راه حل و بهینه سازی انتخاب هایش در طول
مسیر در اختیار دارد. این الگوریتم (هزینۀ مسیر تا الان + هزینۀ تخمینی تا مقصد) را در تحت نظر می گیرد و به محض اینکه
این هزینه از هزینۀ تخمینیِ یکی از گزینه های قبلی فراتر رود، مسیر فعلی را رها میکند و به گزینۀ قبلی باز می گردد و بدین
ترتیب، از رفتن به مسیری طولانی و ناکارآمد، که h(n) به اشتباه به عنوان بهترین مسیر تعیین کرده بود، جلوگیری می کند.

مجددا، از آن جا که این الگوریتم به یک هیوریستیک متکی است، فقط به اندازۀ هیوریستیکی که مورد استفاده قرا ر می دهد خوب
است. ممکن است در برخی موقعیت ها، نسبت به جستجوی اول بهترین حریصانه یا حتی الگوریتم های ناآگاهانه، از کارایی
کمتری برخوردار باشد. برای اینکه جستجوی A* بهینه باشد، تابع هیوریستیک h(n) باید:
  - 1.قابل قبول (Admissible) باشد، یا هرگز هزینۀ واقعی را دست بالا تخمین نزند، و
  - 2.سازگار (Consistent) باشد، یعنی هزینۀ تخمینی مسیر رسیدن به هدفِ از گره جدید، بهعلاوۀ هزینۀ انتقال از گره
قبلی تا این گره، بیشتر یا برابر با هزینۀ تخمینی مسیر رسیدن به هدف از گره قبلی باشد. به بیان ریاضی ، h(n)
زمانی سازگار است که برای هر گره n و گره بعدی n' با هزینۀ گام c ، رابطهی h(n) ≤ h(n') + c برقرار باشد.


### جستجوی تخاصمی (Adversarial Search)
الگوریتم هایی که قبلاً دربارۀ آنها صحبت کردیم باید برای هر سؤال یک پاسخ پیدا کنند، در حالی که در جستجوی تخاصمی،
الگوریتم با حریفی روبرو است که سعی دارد به هدفی متضاد دست یابد. اغلب اوقات، هوش مصنوعی ای که از جستجوی
تخاصمی استفاده می کند، در بازی هایی چون دوز به کار می رود.


### مینی ماکس
مینی ماکس که نوعی الگوریتم جستجوی تخاصمی است، شرایط بُرد را برای یک طرف با (1-) و برای طرف دیگر با (1+)
نشان می دهد. در این الگوریتم عامل کمینه ساز سعی دارد پایین ترین امتیاز را به دست آورد، در حالی که بیشینه ساز به دنبال
کسب بالاترین امتیاز است.

بازنمایی هوش مصنوعی در بازی ایکس او :
  - حالت اولیه (S0) (در مورد نمونۀ ما، یک تختۀ خالی 3 × 3).
  - تابعی (Players(s)) که با داشتن حالت s، مشخص می کند که نوبت کدام بازیکن است (X یا O).
  - تابعی (Actions(S)) که با داشتن حالت s، تمامی حرکات مجاز در این حالت را مشخص می کند (کدام خان هها در
تخته خالی هستند).
  - تابعی (Results(s, a)) که با داشتن حالت s و عمل a، حالت جدیدی را نتیجه می دهد. خروجی در واقع پیکربندی ای
از تخته است که در اثر اجرای عمل a روی حالت s به دست آمده است (حرکت کردن در بازی).
  - تابعی که (Terminal(s)) با داشتن حالت s، بررسی می کند آیا این آخرین مرحلۀ بازی است یا خیر، یعنی آیا کسی
بازی را برده است یا تساوی شده است. اگر بازی تمام شده باشد True را نشان می دهد و در غیر این صورت،
 این False می شود.
  - تابعی (Utility(s)) که با داشتن حالت پایانی s، مقدار مطلوبیت آن را مشخص  می کند: 1-, 0 یا 1+.


## نحوۀ کار الگوریتم
این الگوریتم، به شکل بازگشتی، تمامی بازیهای ممکنی را که می توانند با شروع از حالت فعلی و رسیدن به حالت پایانی
انجام شوند، شبیه سازی می کند. مقدار معادل هر حالت پایانی 1-, 0 یا 1+ است.

### الگوریتم مینی ماکس در بازی دوز
با فرض اینکه الگوریتم می تواند با توجه به حالت تشخیص دهد نوبت کدام بازیکن است، الگوریتم می تواند بفهمد که بازیکن
فعلی، در شرایط بهینۀ بازی، عملی را انتخاب می کند که منجر به حالتی با مقدار کمتر خواهد شد یا بیشتر. بدین ترتیب،
الگوریتم، با کمینه سازی و بیشینه سازی به صورت یک در میان، مقادیر متناظر با حالت های حاصل از انتخاب هر عمل ممکن
را تولید می کند. برای اینکه مثالی عینی تر ارائه دهیم، تصور کنید بازیکن بیشینه ساز در هر نوبت این سؤال را می پرسد
(اگر این عمل را انجام دهم، حالت جدیدی به وجود خواهد آمد. اگر بازیکن کمینه ساز به طور بهینه بازی کند، آن بازیکن چه عملی
را می تواند انجام دهد تا به کمترین مقدار برسد؟) البته برای پاسخگویی به این سؤال، بازیکن بیشینه ساز باید این سؤال را
بپرسد: (برای اینکه بدانم بازیکن کمینه ساز چه کاری انجام خواهد داد، باید همین فرایند را در ذهن کمینه ساز شبیه سازی
کنم: بازیکن کمینه ساز سعی می کند این سؤال را بپرسد: اگر این کار را انجام دهم، بازیکن بیشینه ساز چه کاری انجام خواهد
داد تا به بیشترین مقدار برسد؟) این یک فرایند بازگشتی است و پیدا کردن راهی برای درک آن دشوار است؛ بررسی شبه کد
زیر می تواند به شما کمک کند. در نهایت، بازیکن بیشینه ساز، با استفاده از این فرایند استدلال بازگشتی، مقادیر متناظر با
حالت های حاصل از انتخاب اَعمال ممکن در حالت فعلی را تولید میکند. بعد از به دست آوردن این مقادیر، بازیکن بیشینه ساز
بالاترین امتیاز را انتخاب می کند.

بیشینه ساز، مقادیر محتملِ حالات آینده را بررسی می کند.

اگر بخواهیم به صورت شبه کد بیان کنیم، الگوریتم مینی ماکس به ترتیب زیر عمل می کند:

با توجه به حالت s
  - بازیکن بیشینه ساز عمل a را که بالاترین مقدار Min-Value(Result(s,a)) را تولید می کند از
تابع Actions(s) انتخاب میکند.
  - بازیکن کمینه ساز عمل a را که پایین ترین مقدار Max-Value(Result(s,a)) را تولید می کند از
تابع Actions(s) انتخاب می کند.

### تابع Max-Value(state)
```python
v = -∞
if Terminal(state):
  return Utility(state)
for action in Actions(state): 
  v = Max(v, Min-Value(Result(state, action))) 
return v
```

### تابع Min-Value(state)
```python
v = ∞
if Terminal(state):
  return Utility(state)
for action in Actions(state): 
  v = Min(v, Max-Value(Result(state, action))) 
return v
```
