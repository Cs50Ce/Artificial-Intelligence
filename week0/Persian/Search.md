## هوش مصنوعی
هوش مصنوعی شامل تکنیکهای مختلفی است که در ظاهر به رفتارهای همراه با ادراک توسط کامپیوتر شبیه هستند.
برای مثال، از AI برای تشخیص چهره در عکسهای موجود در رسانه های اجتماعیتان، شکست دادن قهرمان جهانی شطرنج
و پردازش گفتارتان هنگام استفاده از نرم افزارهای سیری یا الکسا استفاده میشود.
در این دوره، بعضی از مفاهیمی که امکان استفاده از AI را فراهم می آورند بررسی میکنیم:

### 1.جست و جو
یافتن راه حل برای مسائل؛ مانند برنامه های مسیر یابی که بهترین مسیر از مبدأ تا مقصد را برایتان پیدا میکنند، یا مانند
سنجیدن حرکت بعدی در هنگام بازی کردن.

### 2.دانش
بازنمایی اطلاعات و استنباط کردن از آ نها.

### 3.عدم قطعیت
مواجهه با رویدادهای غیرقطعی بر اساس احتمالات.

### 4.بهینه سازی
تنها به دنبال پیدا کردن روش صحیحِ حل مسائل نیست، بلکه هدف آن پیدا کردن روش بهتر یا بهترین روش برای حل
مسائل است.

### 5.یادگیری
بهبود عملکرد بر اساس دسترسی به داده ها و تجربیات؛ برای مثال، ایمیل شما قادر است بر اساس تجارب گذشته ایمیل های
اسپم را از غیراسپم تشخیص دهد.

### 6.شبکه های عصبی
ساختار برنامه ای با الهام از مغز انسان که قادر است وظایف را به نحو مؤثری انجام دهد.

### 7.زبان
پردازش زبان های طبیعی که توسط انسان ها تولید و درک میشود.



## جستوجو
مسئله جستجو شامل یک عامل با یک حالت اولیه و یک حالت نهایی است. جستجو در واقع راه حلِ رفتن از حالت اول به
حالت دوم را نشان می دهد. برنامه های مسیریابی از فرایند جستجوی معمولی استفاده می کنند که در آن، عامل (قسمت متفکر
برنامه) مکان فعلی و مقصد مدنظر شما را به عنوان ورودی خود دریافت میکند و بر مبنای یک الگوریتم جستجو، مسیری را
پیشنهاد می دهد. البته شکل های بسیار متنوعی برای مسائل جستجو وجود دارد، از جمله پاز ل ها یا هزارتو ها یافتن راه حل برای پازل پانزده خانه ای اعداد مستلزم استفاده از الگوریتم جستجو است.

### عامل
موجودیتی که محیطش را درک و بر اساس آن عمل میکند. برای مثال، در برنامۀ مسیریابی، عامل نوعی بازنمایی از یک
خودروست که باید تصمیم بگیرد چه اقداماتی را برای رسیدن به مقصد انجام دهد.

### حالت
پیکربندی (configuration) عامل در محیطش؛ برای مثال، در پازل پانزده خانه ای اعداد، حالت یعنی هر یک از شکل هایی که
اعداد روی تخته چیده می شوند.

#### حالت اولیه
حالتی که از آ نجا، الگوریتم جستجو آغاز می شود. در برنامۀ مسیریابی، حالت اولیه همان مکان فعلی است.


### اعمال
انتخاب هایی که می توان در یک حالت انجام داد. به بیان دقیق تر می توان اعمال را به صورت یک تابع تعریف کرد. با دریافت
حالت s به عنوان ورودی، Actions(s) مجموع های از اعمالی را که می توان در حالت s انجام داد، به عنوان خروجی به ما
می دهد. برای مثال، در پازل پانزده خانه ای اعداد، اعمال یک حالت معین عبارتند از راههایی که می توانید مربعها را در چیدمان
فعلی حرکت دهید (عدد 4 اگر مربع خالی در وسط باشد، عدد 3 اگر کنار ضلع باشد، عدد 2 اگر در گوشه قرار گرفته باشد).

### مدل انتقال (Transition model)
مدلی که توصیف می کند که پس از اجرای هر عملِ قابل انجام در هر حالت، چه حالتی به دست می آید. به بیان دقیق تر، مدل
انتقال را می توان به صورت یک تابع تعریف کرد. با دریافت حالت s و عمل a به عنوان ورودی، Results(s, a) حالتی را که
از اجرای عمل a در حالت s به دست می آید، به ما می دهد. برای مثال، با توجه به چیدمان خاصی برای پازل پانزده خانه ای
اعداد (حالت s)، حرکت دادن یکی از مربع ها در یک جهت (عمل a)، چیدمان جدیدی برای پازل ایجاد می کند (حالت جدید).

### فضای حالت
مجموع های از تمامی حالت هایی که از طریق هر نوع توالی اعمال در حالت اولیه، به دست خواهند آمد. برای مثال، در پازل
پانزده خانه ای اعداد، فضای حالت ها شامل 16!/2 پیکربندی تخته میشود که می توان آ نها را از هر نوع حالت اولیه ای
به دست آورد . فضای حالت را می توان به صورت گراف جهت داری مجسم کرد که در آن گره ها نشان دهندۀ حالت ها و پیکان های
بین گره ها نشان دهندۀ اعمال هستند.

### آزمون هدف
شرایطی که تعیین می کند آیا یک حالت معین، حالت نهایی است یا خیر. برای مثال، در برنامۀ مسیریابی، آزمون هدف بررسی
می کند که آیا مکان فعلیِ عامل (بازنمایی خودرو) در مقصد است یا خیر. اگر باشد، پس مسئله حل شده است. اگر نباشد، به
جستجو ادامه می دهیم.

### هزینۀ مسیر
هزینۀ عددیِ متناظر با مسیری معین. برای مثال، برنامۀ مسیریابی صرفاً شما را به هدف نمی رساند؛ بلکه به طور همزمان،
هزینۀ مسیر را به حداقل می رساند و سریع ترین راه ممکن برای رسیدن شما به حالت نهایی تان را پیدا می کند.


## حل مسائل جستجو
راه حل: 
توالی اعمالی که ما را از حالت اولیه به حالت نهایی هدایت می کنند.

راه حل بهینه:
راه حلی که کمترین هزینۀ مسیر را نسبت به تمامی راه حل ها دارد.


در فرایند جستجو، داده ها اغلب در یک گره ذخیره می شوند، گره ساختمان دادهای شامل اطلاعات زیر است:
  - حالت
  - گره وا لد ، که گره فعلی از طریق آن ایجاد شده است
  - عملی که روی حالت والد انجام شد تا به گره فعلی برسد
  - هزینۀ مسیر از حالت اولیه تا این گره


گره ها حاوی اطلاعاتی هستند که باعث می شود به ساختمان داده ای بسیار مفید برای استفاده در الگوریتم های جستجو تبدیل
شوند. آ نها دارای حالتی هستند که می توان آن را با استفاده از آزمون هدف بررسی کرد تا مشخص شود آیا این همان حالت
نهایی است یا خیر. اگر حالت نهایی باشد، آنگاه می توان هزینۀ مسیر گره را با هزینه های مسیر سایر گره ها مقایسه کرد؛ این
کار امکان انتخاب راه حل بهینه را میسر  می سازد. زمانی که گره انتخاب می شود می توان با ذخیره سازی گره والد و عملی که
از والد به گره فعلی هدایت کرده است، تمامی مراحل — از حالت اولیه تا این گره — را ردیابی کرد؛ این توالی اَعمال، راه حل
نام دارد.

اما گره ها صرفاً یک ساختمان داده هستند — آ نها جستجو نمی کنند، فقط حاوی اطلاعات هستند. برای انجام جستجوی
واقعی، از frontier استفاده می کنیم. یعنی مکانیسمی که گره ها را (مدیریت می کند). frontier کار خود را با حالت اولیه
و مجموعه ای خالی از گزینه های بررسی شده آغاز می کند. سپس، اَعمال زیر را تکرار می کند تا زمانی که راه حلی به دست آید:

حلقه ی تکرار:

#### 1.اگر frontier خالی بود
  - متوقف شوید. هیچ راه حلی برای مسئله وجود ندارد.
 
#### 2.گره ی را از frontier بردارید. این همان گرهی است که بررسی خواهد شد.
 
#### 3.اگر گره حاوی حالت نهایی بود،
  - راه حل به دست آمده است. متوقف شوید.
در غیر این صورت،
  - گره را بسط دهید (تمامی گره های جدیدی را که می توان از این گره به دست آورد پیدا کنید) و گره های
به دست آمده را به frontier اضافه کنید.
  - گره فعلی را به مجموعۀ بررسی شده ها اضافه کنید.


## جستجوی اول عمق (DFS)
در تشریح قبلی frontier ، یک مسئله ناگفته ماند. در مرحلۀ 1 شبه کد بالا، کدام گره باید برداشته شود؟ این انتخاب، روی
کیفیت راه حل و سرعت دستیابی به آن تأثیر می گذارد. به رو شهای مختلفی میتوان دریافت که کدام گره ها باید اول بررسی
شوند، که دو مورد از این روش ها را می توان با استفاده از ساختمان داده ی پشته (در جستجوی اول عمق) و صف (در جستجوی
اول سطح (BFS) نشان داد).
با رویکرد جستجوی اول عمق (DFS) شروع می کنیم.

الگوریتم جستجوی اول عمق، ابتدا یک مسیر را کامل طی می کند و سپس مسیر دیگری را امتحان می کند. در این الگوریتم،frontier
با استفاده از ساختمان داده پشته مدیریت می شود. تکیه کلامی که باید در اینجا به یاد داشته باشید(آخرین ورودی, اولین خروجی)
است. پس از اینکه گرهها به » اولین خروجی frontier اضافه شدند، اولین گرهی که باید حذف و بررسی شود، آخرین گره
اضافه شده است. این امر باعث میشود الگوریتم جستجویی داشته باشیم که در اولین جهتی که در مسیرش قرار میگیرد، تا
بیشترین عمق ممکن پیش می رود و همۀ جهت های دیگر را به بعد موکول میکند.
(مثال غیردرسی: مثلاً در نظر بگیرید که به دنبال کلیدهایتان می گردید. در رویکرد جستجوی اول عمق، اگر بخواهید کار را
با جستجوی شلوارتان شروع کنید باید همۀ جیب ها را بگردید، آ نها را خالی کنید و وسایل آن را به دقت بگردید. تنها پس از
اینکه جستجو در همۀ جیب های شلوارتان را تمام کرده باشید، از جستجوی شلوارتان دست می کشید و جای دیگری را
میگردید.)

